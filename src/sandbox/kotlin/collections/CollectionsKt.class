// IntelliJ API Decompiler stub source generated from a class file
// Implementation of methods is not available

package kotlin.collections

@kotlin.internal.InlineOnly internal inline fun copyToArrayImpl(collection: kotlin.collections.Collection<*>): kotlin.Array<kotlin.Any?> { /* compiled code */ }

@kotlin.internal.InlineOnly internal inline fun <T> copyToArrayImpl(collection: kotlin.collections.Collection<*>, array: kotlin.Array<T>): kotlin.Array<T> { /* compiled code */ }

public fun <T> listOf(element: T): kotlin.collections.List<T> { /* compiled code */ }

internal fun <T> kotlin.Array<out T>.copyToArrayOfAny(isVarargs: kotlin.Boolean): kotlin.Array<out kotlin.Any?> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> java.util.Enumeration<T>.toList(): kotlin.collections.List<T> { /* compiled code */ }

public val kotlin.collections.Collection<*>.indices: kotlin.ranges.IntRange /* compiled code */

public val <T> kotlin.collections.List<T>.lastIndex: kotlin.Int /* compiled code */

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> List(size: kotlin.Int, init: (kotlin.Int) -> T): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> MutableList(size: kotlin.Int, init: (kotlin.Int) -> T): kotlin.collections.MutableList<T> { /* compiled code */ }

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> arrayListOf(): kotlin.collections.ArrayList<T> /* = java.util.ArrayList<T> */ { /* compiled code */ }

public fun <T> arrayListOf(vararg elements: T): kotlin.collections.ArrayList<T> /* = java.util.ArrayList<T> */ { /* compiled code */ }

public fun <T> emptyList(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> listOf(): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> listOf(vararg elements: T): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Any> listOfNotNull(element: T?): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Any> listOfNotNull(vararg elements: T?): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> mutableListOf(): kotlin.collections.MutableList<T> { /* compiled code */ }

public fun <T> mutableListOf(vararg elements: T): kotlin.collections.MutableList<T> { /* compiled code */ }

private fun rangeCheck(size: kotlin.Int, fromIndex: kotlin.Int, toIndex: kotlin.Int): kotlin.Unit { /* compiled code */ }

internal fun <T> kotlin.Array<out T>.asCollection(): kotlin.collections.Collection<T> { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.binarySearch(element: T, comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */, fromIndex: kotlin.Int /* = compiled code */, toIndex: kotlin.Int /* = compiled code */): kotlin.Int { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.binarySearch(fromIndex: kotlin.Int /* = compiled code */, toIndex: kotlin.Int /* = compiled code */, comparison: (T) -> kotlin.Int): kotlin.Int { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.List<T?>.binarySearch(element: T?, fromIndex: kotlin.Int /* = compiled code */, toIndex: kotlin.Int /* = compiled code */): kotlin.Int { /* compiled code */ }

public inline fun <T, K : kotlin.Comparable<K>> kotlin.collections.List<T>.binarySearchBy(key: K?, fromIndex: kotlin.Int /* = compiled code */, toIndex: kotlin.Int /* = compiled code */, crossinline selector: (T) -> K?): kotlin.Int { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.Collection<T>.containsAll(elements: kotlin.collections.Collection<T>): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>.isNotEmpty(): kotlin.Boolean { /* compiled code */ }

internal fun <T> kotlin.collections.List<T>.optimizeReadOnlyList(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>?.orEmpty(): kotlin.collections.Collection<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>?.orEmpty(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> Iterable(crossinline iterator: () -> kotlin.collections.Iterator<T>): kotlin.collections.Iterable<T> { /* compiled code */ }

@kotlin.PublishedApi internal fun <T> kotlin.collections.Iterable<T>.collectionSizeOrDefault(default: kotlin.Int): kotlin.Int { /* compiled code */ }

@kotlin.PublishedApi internal fun <T> kotlin.collections.Iterable<T>.collectionSizeOrNull(): kotlin.Int? { /* compiled code */ }

internal fun <T> kotlin.collections.Iterable<T>.convertToSetForSetOperation(): kotlin.collections.Collection<T> { /* compiled code */ }

internal fun <T> kotlin.collections.Iterable<T>.convertToSetForSetOperationWith(source: kotlin.collections.Iterable<T>): kotlin.collections.Collection<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<kotlin.collections.Iterable<T>>.flatten(): kotlin.collections.List<T> { /* compiled code */ }

private fun <T> kotlin.collections.Collection<T>.safeToConvertToSet(): kotlin.Boolean { /* compiled code */ }

public fun <T, R> kotlin.collections.Iterable<kotlin.Pair<T, R>>.unzip(): kotlin.Pair<kotlin.collections.List<T>, kotlin.collections.List<R>> { /* compiled code */ }

public operator fun <T> java.util.Enumeration<T>.iterator(): kotlin.collections.Iterator<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterator<T>.forEach(operation: (T) -> kotlin.Unit): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.Iterator<T>.iterator(): kotlin.collections.Iterator<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterator<T>.withIndex(): kotlin.collections.Iterator<kotlin.collections.IndexedValue<T>> { /* compiled code */ }

@kotlin.internal.InlineOnly @kotlin.SinceKotlin public inline fun <T> kotlin.collections.MutableList<T>.fill(value: T): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly @kotlin.SinceKotlin public inline fun <T> kotlin.collections.MutableList<T>.shuffle(): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly @kotlin.SinceKotlin public inline fun <T> kotlin.collections.MutableList<T>.shuffle(random: java.util.Random): kotlin.Unit { /* compiled code */ }

@kotlin.SinceKotlin public fun <T> kotlin.collections.Iterable<T>.shuffled(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.SinceKotlin public fun <T> kotlin.collections.Iterable<T>.shuffled(random: java.util.Random): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.MutableList<T>.sort(): kotlin.Unit { /* compiled code */ }

@kotlin.Deprecated @kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.MutableList<T>.sort(comparison: (T, T) -> kotlin.Int): kotlin.Unit { /* compiled code */ }

@kotlin.Deprecated @kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.MutableList<T>.sort(comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */): kotlin.Unit { /* compiled code */ }

public fun <T> kotlin.collections.MutableList<T>.sortWith(comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */): kotlin.Unit { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.addAll(elements: kotlin.Array<out T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.addAll(elements: kotlin.collections.Iterable<T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.addAll(elements: kotlin.sequences.Sequence<T>): kotlin.Boolean { /* compiled code */ }

private fun <T> kotlin.collections.MutableIterable<T>.filterInPlace(predicate: (T) -> kotlin.Boolean, predicateResultToRemove: kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

private fun <T> kotlin.collections.MutableList<T>.filterInPlace(predicate: (T) -> kotlin.Boolean, predicateResultToRemove: kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.minusAssign(element: T): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.minusAssign(elements: kotlin.Array<T>): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.minusAssign(elements: kotlin.collections.Iterable<T>): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.minusAssign(elements: kotlin.sequences.Sequence<T>): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.plusAssign(element: T): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.plusAssign(elements: kotlin.Array<T>): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.plusAssign(elements: kotlin.collections.Iterable<T>): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.MutableCollection<in T>.plusAssign(elements: kotlin.sequences.Sequence<T>): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.remove(element: T): kotlin.Boolean { /* compiled code */ }

@kotlin.Deprecated @kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.MutableList<T>.remove(index: kotlin.Int): T { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.removeAll(elements: kotlin.Array<out T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.removeAll(elements: kotlin.collections.Iterable<T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.removeAll(elements: kotlin.sequences.Sequence<T>): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.removeAll(elements: kotlin.collections.Collection<T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableIterable<T>.removeAll(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableList<T>.removeAll(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.retainAll(elements: kotlin.Array<out T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.retainAll(elements: kotlin.collections.Iterable<T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableCollection<in T>.retainAll(elements: kotlin.sequences.Sequence<T>): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.MutableCollection<out T>.retainAll(elements: kotlin.collections.Collection<T>): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableIterable<T>.retainAll(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.MutableList<T>.retainAll(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

private fun kotlin.collections.MutableCollection<*>.retainNothing(): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.asReversed(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.jvm.JvmName public fun <T> kotlin.collections.MutableList<T>.asReversed(): kotlin.collections.MutableList<T> { /* compiled code */ }

private fun kotlin.collections.List<*>.reverseElementIndex(index: kotlin.Int): kotlin.Int { /* compiled code */ }

private fun kotlin.collections.List<*>.reversePositionIndex(index: kotlin.Int): kotlin.Int { /* compiled code */ }

public fun <R> kotlin.collections.Iterable<*>.filterIsInstance(klass: java.lang.Class<R>): kotlin.collections.List<R> { /* compiled code */ }

public fun <C : kotlin.collections.MutableCollection<in R>, R> kotlin.collections.Iterable<*>.filterIsInstanceTo(destination: C, klass: java.lang.Class<R>): C { /* compiled code */ }

public fun <T> kotlin.collections.MutableList<T>.reverse(): kotlin.Unit { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.toSortedSet(): java.util.SortedSet<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.toSortedSet(comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */): java.util.SortedSet<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.all(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.any(): kotlin.Boolean { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.any(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Iterable<T>.asIterable(): kotlin.collections.Iterable<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.asSequence(): kotlin.sequences.Sequence<T> { /* compiled code */ }

public inline fun <T, K, V> kotlin.collections.Iterable<T>.associate(transform: (T) -> kotlin.Pair<K, V>): kotlin.collections.Map<K, V> { /* compiled code */ }

public inline fun <T, K> kotlin.collections.Iterable<T>.associateBy(keySelector: (T) -> K): kotlin.collections.Map<K, T> { /* compiled code */ }

public inline fun <T, K, V> kotlin.collections.Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): kotlin.collections.Map<K, V> { /* compiled code */ }

public inline fun <T, K, M : kotlin.collections.MutableMap<in K, in T>> kotlin.collections.Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M { /* compiled code */ }

public inline fun <T, K, V, M : kotlin.collections.MutableMap<in K, in V>> kotlin.collections.Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M { /* compiled code */ }

public inline fun <T, K, V, M : kotlin.collections.MutableMap<in K, in V>> kotlin.collections.Iterable<T>.associateTo(destination: M, transform: (T) -> kotlin.Pair<K, V>): M { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Byte>.average(): kotlin.Double { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Double>.average(): kotlin.Double { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Float>.average(): kotlin.Double { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Int>.average(): kotlin.Double { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Long>.average(): kotlin.Double { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Short>.average(): kotlin.Double { /* compiled code */ }

@kotlin.SinceKotlin public fun <T> kotlin.collections.Iterable<T>.chunked(size: kotlin.Int): kotlin.collections.List<kotlin.collections.List<T>> { /* compiled code */ }

@kotlin.SinceKotlin public fun <T, R> kotlin.collections.Iterable<T>.chunked(size: kotlin.Int, transform: (kotlin.collections.List<T>) -> R): kotlin.collections.List<R> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.List<T>.component1(): T { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.List<T>.component2(): T { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.List<T>.component3(): T { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.List<T>.component4(): T { /* compiled code */ }

@kotlin.internal.InlineOnly public inline operator fun <T> kotlin.collections.List<T>.component5(): T { /* compiled code */ }

public operator fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.Iterable<T>.contains(element: T): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>.count(): kotlin.Int { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.count(): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.count(predicate: (T) -> kotlin.Boolean): kotlin.Int { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.distinct(): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T, K> kotlin.collections.Iterable<T>.distinctBy(selector: (T) -> K): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.drop(n: kotlin.Int): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.dropLast(n: kotlin.Int): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.List<T>.dropLastWhile(predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.dropWhile(predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.elementAt(index: kotlin.Int): T { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>.elementAt(index: kotlin.Int): T { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.elementAtOrElse(index: kotlin.Int, defaultValue: (kotlin.Int) -> T): T { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>.elementAtOrElse(index: kotlin.Int, defaultValue: (kotlin.Int) -> T): T { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.elementAtOrNull(index: kotlin.Int): T? { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>.elementAtOrNull(index: kotlin.Int): T? { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.filter(predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.filterIndexed(predicate: (kotlin.Int, T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T, C : kotlin.collections.MutableCollection<in T>> kotlin.collections.Iterable<T>.filterIndexedTo(destination: C, predicate: (kotlin.Int, T) -> kotlin.Boolean): C { /* compiled code */ }

public inline fun <reified R> kotlin.collections.Iterable<*>.filterIsInstance(): kotlin.collections.List<@kotlin.internal.NoInfer R> { /* compiled code */ }

public inline fun <reified R, C : kotlin.collections.MutableCollection<in R>> kotlin.collections.Iterable<*>.filterIsInstanceTo(destination: C): C { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.filterNot(predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Any> kotlin.collections.Iterable<T?>.filterNotNull(): kotlin.collections.List<T> { /* compiled code */ }

public fun <C : kotlin.collections.MutableCollection<in T>, T : kotlin.Any> kotlin.collections.Iterable<T?>.filterNotNullTo(destination: C): C { /* compiled code */ }

public inline fun <T, C : kotlin.collections.MutableCollection<in T>> kotlin.collections.Iterable<T>.filterNotTo(destination: C, predicate: (T) -> kotlin.Boolean): C { /* compiled code */ }

public inline fun <T, C : kotlin.collections.MutableCollection<in T>> kotlin.collections.Iterable<T>.filterTo(destination: C, predicate: (T) -> kotlin.Boolean): C { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Iterable<T>.find(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Iterable<T>.findLast(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>.findLast(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.first(): T { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.first(predicate: (T) -> kotlin.Boolean): T { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.first(): T { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.firstOrNull(): T? { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.firstOrNull(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.firstOrNull(): T? { /* compiled code */ }

public inline fun <T, R> kotlin.collections.Iterable<T>.flatMap(transform: (T) -> kotlin.collections.Iterable<R>): kotlin.collections.List<R> { /* compiled code */ }

public inline fun <T, R, C : kotlin.collections.MutableCollection<in R>> kotlin.collections.Iterable<T>.flatMapTo(destination: C, transform: (T) -> kotlin.collections.Iterable<R>): C { /* compiled code */ }

public inline fun <T, R> kotlin.collections.Iterable<T>.fold(initial: R, operation: (R, T) -> R): R { /* compiled code */ }

public inline fun <T, R> kotlin.collections.Iterable<T>.foldIndexed(initial: R, operation: (kotlin.Int, R, T) -> R): R { /* compiled code */ }

public inline fun <T, R> kotlin.collections.List<T>.foldRight(initial: R, operation: (T, R) -> R): R { /* compiled code */ }

public inline fun <T, R> kotlin.collections.List<T>.foldRightIndexed(initial: R, operation: (kotlin.Int, T, R) -> R): R { /* compiled code */ }

@kotlin.internal.HidesMembers public inline fun <T> kotlin.collections.Iterable<T>.forEach(action: (T) -> kotlin.Unit): kotlin.Unit { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.forEachIndexed(action: (kotlin.Int, T) -> kotlin.Unit): kotlin.Unit { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>.getOrElse(index: kotlin.Int, defaultValue: (kotlin.Int) -> T): T { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.getOrNull(index: kotlin.Int): T? { /* compiled code */ }

public inline fun <T, K> kotlin.collections.Iterable<T>.groupBy(keySelector: (T) -> K): kotlin.collections.Map<K, kotlin.collections.List<T>> { /* compiled code */ }

public inline fun <T, K, V> kotlin.collections.Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): kotlin.collections.Map<K, kotlin.collections.List<V>> { /* compiled code */ }

public inline fun <T, K, M : kotlin.collections.MutableMap<in K, kotlin.collections.MutableList<T>>> kotlin.collections.Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M { /* compiled code */ }

public inline fun <T, K, V, M : kotlin.collections.MutableMap<in K, kotlin.collections.MutableList<V>>> kotlin.collections.Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M { /* compiled code */ }

@kotlin.SinceKotlin public inline fun <T, K> kotlin.collections.Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): kotlin.collections.Grouping<T, K> { /* compiled code */ }

public fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.Iterable<T>.indexOf(element: T): kotlin.Int { /* compiled code */ }

public fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.List<T>.indexOf(element: T): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.indexOfFirst(predicate: (T) -> kotlin.Boolean): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.List<T>.indexOfFirst(predicate: (T) -> kotlin.Boolean): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.indexOfLast(predicate: (T) -> kotlin.Boolean): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.List<T>.indexOfLast(predicate: (T) -> kotlin.Boolean): kotlin.Int { /* compiled code */ }

public infix fun <T> kotlin.collections.Iterable<T>.intersect(other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T> { /* compiled code */ }

public fun <T, A : kotlin.text.Appendable /* = java.lang.Appendable */> kotlin.collections.Iterable<T>.joinTo(buffer: A, separator: kotlin.CharSequence /* = compiled code */, prefix: kotlin.CharSequence /* = compiled code */, postfix: kotlin.CharSequence /* = compiled code */, limit: kotlin.Int /* = compiled code */, truncated: kotlin.CharSequence /* = compiled code */, transform: ((T) -> kotlin.CharSequence)? /* = compiled code */): A { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.joinToString(separator: kotlin.CharSequence /* = compiled code */, prefix: kotlin.CharSequence /* = compiled code */, postfix: kotlin.CharSequence /* = compiled code */, limit: kotlin.Int /* = compiled code */, truncated: kotlin.CharSequence /* = compiled code */, transform: ((T) -> kotlin.CharSequence)? /* = compiled code */): kotlin.String { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.last(): T { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.last(predicate: (T) -> kotlin.Boolean): T { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.last(): T { /* compiled code */ }

public inline fun <T> kotlin.collections.List<T>.last(predicate: (T) -> kotlin.Boolean): T { /* compiled code */ }

public fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.Iterable<T>.lastIndexOf(element: T): kotlin.Int { /* compiled code */ }

public fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.List<T>.lastIndexOf(element: T): kotlin.Int { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.lastOrNull(): T? { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.lastOrNull(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.lastOrNull(): T? { /* compiled code */ }

public inline fun <T> kotlin.collections.List<T>.lastOrNull(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

public inline fun <T, R> kotlin.collections.Iterable<T>.map(transform: (T) -> R): kotlin.Int { /* compiled code */ }

public inline fun <T, R> kotlin.collections.Iterable<T>.mapIndexed(transform: (kotlin.Int, T) -> R): kotlin.collections.List<R> { /* compiled code */ }

public inline fun <T, R : kotlin.Any> kotlin.collections.Iterable<T>.mapIndexedNotNull(transform: (kotlin.Int, T) -> R?): kotlin.collections.List<R> { /* compiled code */ }

public inline fun <T, R : kotlin.Any, C : kotlin.collections.MutableCollection<in R>> kotlin.collections.Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (kotlin.Int, T) -> R?): C { /* compiled code */ }

public inline fun <T, R, C : kotlin.collections.MutableCollection<in R>> kotlin.collections.Iterable<T>.mapIndexedTo(destination: C, transform: (kotlin.Int, T) -> R): C { /* compiled code */ }

public inline fun <T, R : kotlin.Any> kotlin.collections.Iterable<T>.mapNotNull(transform: (T) -> R?): kotlin.collections.List<R> { /* compiled code */ }

public inline fun <T, R : kotlin.Any, C : kotlin.collections.MutableCollection<in R>> kotlin.collections.Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C { /* compiled code */ }

public inline fun <T, R, C : kotlin.collections.MutableCollection<in R>> kotlin.collections.Iterable<T>.mapTo(destination: C, transform: (T) -> R): C { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.max(): T? { /* compiled code */ }

@kotlin.SinceKotlin public fun kotlin.collections.Iterable<kotlin.Double>.max(): kotlin.Double? { /* compiled code */ }

@kotlin.SinceKotlin public fun kotlin.collections.Iterable<kotlin.Float>.max(): kotlin.Float? { /* compiled code */ }

public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.maxBy(selector: (T) -> R): T? { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.maxWith(comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */): T? { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.min(): T? { /* compiled code */ }

@kotlin.SinceKotlin public fun kotlin.collections.Iterable<kotlin.Double>.min(): kotlin.Double? { /* compiled code */ }

@kotlin.SinceKotlin public fun kotlin.collections.Iterable<kotlin.Float>.min(): kotlin.Float? { /* compiled code */ }

public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.minBy(selector: (T) -> R): T? { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.minWith(comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */): T? { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.minus(element: T): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.minus(elements: kotlin.Array<out T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.minus(elements: kotlin.collections.Iterable<T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.minus(elements: kotlin.sequences.Sequence<T>): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Iterable<T>.minusElement(element: T): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.none(): kotlin.Boolean { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.none(predicate: (T) -> kotlin.Boolean): kotlin.Boolean { /* compiled code */ }

@kotlin.SinceKotlin public inline fun <T, C : kotlin.collections.Iterable<T>> C.onEach(action: (T) -> kotlin.Unit): C { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.partition(predicate: (T) -> kotlin.Boolean): kotlin.Pair<kotlin.collections.List<T>, kotlin.collections.List<T>> { /* compiled code */ }

public operator fun <T> kotlin.collections.Collection<T>.plus(element: T): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Collection<T>.plus(elements: kotlin.Array<out T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Collection<T>.plus(elements: kotlin.collections.Iterable<T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Collection<T>.plus(elements: kotlin.sequences.Sequence<T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.plus(element: T): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.plus(elements: kotlin.Array<out T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.plus(elements: kotlin.collections.Iterable<T>): kotlin.collections.List<T> { /* compiled code */ }

public operator fun <T> kotlin.collections.Iterable<T>.plus(elements: kotlin.sequences.Sequence<T>): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>.plusElement(element: T): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Iterable<T>.plusElement(element: T): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <S, T : S> kotlin.collections.Iterable<T>.reduce(operation: (S, T) -> S): S { /* compiled code */ }

public inline fun <S, T : S> kotlin.collections.Iterable<T>.reduceIndexed(operation: (kotlin.Int, S, T) -> S): S { /* compiled code */ }

public inline fun <S, T : S> kotlin.collections.List<T>.reduceRight(operation: (T, S) -> S): S { /* compiled code */ }

public inline fun <S, T : S> kotlin.collections.List<T>.reduceRightIndexed(operation: (kotlin.Int, T, S) -> S): S { /* compiled code */ }

public fun <T : kotlin.Any> kotlin.collections.Iterable<T?>.requireNoNulls(): kotlin.collections.Iterable<T> { /* compiled code */ }

public fun <T : kotlin.Any> kotlin.collections.List<T?>.requireNoNulls(): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.reversed(): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.single(): T { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.single(predicate: (T) -> kotlin.Boolean): T { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.single(): T { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.singleOrNull(): T? { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.singleOrNull(predicate: (T) -> kotlin.Boolean): T? { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.singleOrNull(): T? { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.slice(indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.slice(indices: kotlin.ranges.IntRange): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortBy(crossinline selector: (T) -> R?): kotlin.Unit { /* compiled code */ }

public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): kotlin.Unit { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.MutableList<T>.sortDescending(): kotlin.Unit { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.sorted(): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.sortedBy(crossinline selector: (T) -> R?): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.sortedDescending(): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.sortedWith(comparator: kotlin.Comparator<in T> /* = java.util.Comparator<in T> */): kotlin.collections.List<T> { /* compiled code */ }

public infix fun <T> kotlin.collections.Iterable<T>.subtract(other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T> { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Byte>.sum(): kotlin.Int { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Double>.sum(): kotlin.Double { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Float>.sum(): kotlin.Float { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Int>.sum(): kotlin.Int { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Long>.sum(): kotlin.Long { /* compiled code */ }

@kotlin.jvm.JvmName public fun kotlin.collections.Iterable<kotlin.Short>.sum(): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.sumBy(selector: (T) -> kotlin.Int): kotlin.Int { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.sumByDouble(selector: (T) -> kotlin.Double): kotlin.Double { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.take(n: kotlin.Int): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.takeLast(n: kotlin.Int): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.List<T>.takeLastWhile(predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public inline fun <T> kotlin.collections.Iterable<T>.takeWhile(predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T> { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Boolean>.toBooleanArray(): kotlin.BooleanArray { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Byte>.toByteArray(): kotlin.ByteArray { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Char>.toCharArray(): kotlin.CharArray { /* compiled code */ }

public fun <T, C : kotlin.collections.MutableCollection<in T>> kotlin.collections.Iterable<T>.toCollection(destination: C): C { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Double>.toDoubleArray(): kotlin.DoubleArray { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Float>.toFloatArray(): kotlin.FloatArray { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.toHashSet(): kotlin.collections.HashSet<T> /* = java.util.HashSet<T> */ { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Int>.toIntArray(): kotlin.IntArray { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.toList(): kotlin.collections.List<T> { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Long>.toLongArray(): kotlin.LongArray { /* compiled code */ }

public fun <T> kotlin.collections.Collection<T>.toMutableList(): kotlin.collections.MutableList<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.toMutableList(): kotlin.collections.MutableList<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.toMutableSet(): kotlin.collections.MutableSet<T> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.toSet(): kotlin.collections.Set<T> { /* compiled code */ }

public fun kotlin.collections.Collection<kotlin.Short>.toShortArray(): kotlin.ShortArray { /* compiled code */ }

public infix fun <T> kotlin.collections.Iterable<T>.union(other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T> { /* compiled code */ }

@kotlin.SinceKotlin public fun <T> kotlin.collections.Iterable<T>.windowed(size: kotlin.Int, step: kotlin.Int /* = compiled code */, partialWindows: kotlin.Boolean /* = compiled code */): kotlin.collections.List<kotlin.collections.List<T>> { /* compiled code */ }

@kotlin.SinceKotlin public fun <T, R> kotlin.collections.Iterable<T>.windowed(size: kotlin.Int, step: kotlin.Int /* = compiled code */, partialWindows: kotlin.Boolean /* = compiled code */, transform: (kotlin.collections.List<T>) -> R): kotlin.collections.List<R> { /* compiled code */ }

public fun <T> kotlin.collections.Iterable<T>.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<T>> { /* compiled code */ }

public infix fun <T, R> kotlin.collections.Iterable<T>.zip(other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<T, R>> { /* compiled code */ }

public inline fun <T, R, V> kotlin.collections.Iterable<T>.zip(other: kotlin.Array<out R>, transform: (T, R) -> V): kotlin.collections.List<V> { /* compiled code */ }

public infix fun <T, R> kotlin.collections.Iterable<T>.zip(other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<T, R>> { /* compiled code */ }

public inline fun <T, R, V> kotlin.collections.Iterable<T>.zip(other: kotlin.collections.Iterable<R>, transform: (T, R) -> V): kotlin.collections.List<V> { /* compiled code */ }

@kotlin.SinceKotlin public fun <T> kotlin.collections.Iterable<T>.zipWithNext(): kotlin.collections.List<kotlin.Pair<T, T>> { /* compiled code */ }

@kotlin.SinceKotlin public inline fun <T, R> kotlin.collections.Iterable<T>.zipWithNext(transform: (T, T) -> R): kotlin.collections.List<R> { /* compiled code */ }

